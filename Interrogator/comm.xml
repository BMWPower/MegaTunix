<?xml version="1.0"?>
<comms>
	<potential_args>
		<arg>
			<name>MS2_CAN_ID</name>
			<desc>This is the CAN ID, 0-15 is valid.</desc>
			<type>_DATA_</type>
			<internal_name>canID</internal_name>
			<size>_U08_</size>
		</arg>
		<arg>
			<name>MS2_TABLE_INDEX</name>
			<desc>This is the table index in the firmware,  0-3 are lookuptables, 4-5 are data, and 6 is rtvars, these are analagous to pages from MS-I extra</desc>
			<type>_DATA_</type>
			<internal_name>truepgnum</internal_name>
			<size>_U08_</size>
		</arg>
		<arg>
			<name>MS2_NUM_BYTES</name>
			<desc>Length of data to transfer (read or write), MSB format</desc>
			<type>_DATA_</type>
			<internal_name>num_bytes</internal_name>
			<size>_U16_</size>
		</arg>
		<arg>
			<name>MS1_NUM_BYTES</name>
			<desc>Length of data to transfer (read or write)</desc>
			<type>_DATA_</type>
			<internal_name>num_bytes</internal_name>
			<size>_U08_</size>
		</arg>
	
		<arg>
			<name>MS1_PAGE</name>
			<desc>Page inside ECU firmware</desc>
			<type>_DATA_</type>
			<internal_name>truepgnum</internal_name>
			<size>_U08_</size>
		</arg>
		<arg>
			<name>MS1_OFFSET</name>
			<desc>Offset from the beginning of the page.</desc>
			<type>_DATA_</type>
			<internal_name>offset</internal_name>
			<size>_U08_</size>
		</arg>
		<arg>
			<name>MS2_OFFSET</name>
			<desc>Offset from the beginning of the table. This is in MSB format</desc>
			<type>_DATA_</type>
			<internal_name>offset</internal_name>
			<size>_U16_</size>
		</arg>
		<arg>
			<name>MS1_BYTE</name>
			<desc>byte to transfer to ECU, length is 1 byte </desc>
			<type>_DATA_</type>
			<internal_name>value</internal_name>
			<size>_U08_</size>
		</arg>
		<arg>	
			<name>DATACHUNK</name>
			<desc>Data to transfer to ECU, length is variable. Only applies to chunk write compatible firmwares </desc>
			<type>_DATA_</type>
			<internal_name>data</internal_name>
			<size>_UNDEF_</size>
		</arg>
		<arg>
			<name>PAUSE_50MS</name>
			<desc>Pause for 50ms.</desc>
			<type>_ACTION_</type>
			<action>_SLEEP_</action>
			<action_arg>50000</action_arg>
		</arg>
		<arg>
			<name>PAUSE_500MS</name>
			<desc>Pause for 500ms.</desc>
			<type>_ACTION_</type>
			<action>_SLEEP_</action>
			<action_arg>500000</action_arg>
		</arg>
		<arg>
			<name>SEND_X</name>
			<desc> Sends a simple "X"</desc>
			<type>_STATIC_STRING_</type>
			<string>X</string>
		</arg>
	</potential_args>
	<commands>
		<cmd>
			<name>ms1_extra_reboot_get_error</name>
			<desc>Reboots the ECU and grabs the error string</desc>
			<type>_WRITE_CMD_</type>
			<base>!!</base>
			<args>
				<arg>PAUSE_50MS</arg>
				<arg>SEND_X</arg>
			</args>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS1_GETERROR_</helper_func_arg>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function>enable_reboot_button_cb</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms1_std_rtvars</name>
			<desc>Gets the realtime vars from the ECU, returns a var length block</desc>
			<type>_WRITE_CMD_</type>
			<base>A</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS1_RT_VARS_</helper_func_arg>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function>update_runtime_vars</function>
				<function>rt_update_logview_traces</function>
				<function>run_datalog</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms1_extra_rtvars</name>
			<desc>Gets the realtime vars from the ECU, returns a var length block</desc>
			<type>_WRITE_CMD_</type>
			<base>R</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS1_RT_VARS_</helper_func_arg>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function>update_runtime_vars</function>
				<function>rt_update_logview_traces</function>
				<function>run_datalog</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_std_rtvars</name>
			<desc>Gets the realtime vars from the ECU, returns a var length block</desc>
			<type>_WRITE_CMD_</type>
			<base>a</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
			</args>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS2_RT_VARS_</helper_func_arg>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function>update_runtime_vars</function>
				<function>rt_update_logview_traces</function>
				<function>run_datalog</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_generic_read</name>
			<desc>Generic read function, gets data from any can_id table and offset</desc>
			<type>_WRITE_CMD_</type>
			<base>r</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
				<arg>MS2_OFFSET</arg>
				<arg>MS2_NUM_BYTES</arg>
				<arg>DATACHUNK</arg>
			</args>
		</cmd>
		<cmd>
			<name>ms1_generic_write</name>
			<desc>Generic write function, sets data to any page and offset</desc>
			<type>_WRITE_CMD_</type>
			<base>W</base>
			<args>
				<arg>MS1_OFFSET</arg>
				<arg>MS1_BYTE</arg>
			</args>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function_w_arg>update_write_status</function_w_arg>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms1_chunk_write</name>
			<desc>MS1 Chunk write function, sets data to any page and offset</desc>
			<type>_WRITE_CMD_</type>
			<base>X</base>
			<args>
				<arg>MS1_OFFSET</arg>
				<arg>MS1_NUM_BYTES</arg>
				<arg>DATACHUNK</arg>
			</args>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function_w_arg>update_write_status</function_w_arg>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_generic_write</name>
			<desc>Generic write function, sets data to any can_id. table and offset</desc>
			<type>_WRITE_CMD_</type>
			<base>w</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
				<arg>MS2_OFFSET</arg>
				<arg>MS2_NUM_BYTES</arg>
				<arg>DATACHUNK</arg>
			</args>
			<post_functions>
			<defer_post_functions>FALSE</defer_post_functions>
				<function_w_arg>update_write_status</function_w_arg>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_echo_write</name>
			<desc>echo-back write function, sets data to any can_id. table and offset, then echos everything back to the sender</desc>
			<type>_WRITE_CMD_</type>
			<base>e</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
				<arg>MS2_OFFSET</arg>
				<arg>MS2_NUM_BYTES</arg>
				<arg>DATACHUNK</arg>
			</args>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_WRITE_VERIFY_</helper_func_arg>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function_w_arg>update_write_status</function_w_arg>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_verify</name>
			<desc>verify function, does a RAM to flash comparison for the passed canid and table and returns the number of MISMATCHED bytes</desc>
			<type>_WRITE_CMD_</type>
			<base>y</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
			</args>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MISMATCH_COUNT_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms1_burn</name>
			<desc>burns the current page flash</desc>
			<type>_WRITE_CMD_</type>
			<base>B</base>
			<args>
				<arg>PAUSE_500MS</arg>
			</args>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function>post_burn_cb</function>
				<function>set_store_black_cb</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_burn_all</name>
			<desc>Calls a function to burn ALL applicable ms2 pages to flash</desc>
			<type>_FUNC_CALL_</type>
			<func_call_name>ms2_burn_all_helper</func_call_name>
			<func_call_arg>_MS2_STD_</func_call_arg>
			<defer_post_functions>TRUE</defer_post_functions>
			<post_functions>
				<function>post_burn_cb</function>
				<function>set_store_black_cb</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_burn</name>
			<desc>burns the passed can_id and table_index from ram to flash</desc>
			<type>_WRITE_CMD_</type>
			<base>b</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
				<arg>PAUSE_500MS</arg>
			</args>
			<post_functions>
				<function_w_arg>post_single_burn_cb</function_w_arg>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_table_reflash</name>
			<desc>This command wipes the flash of the passed table index, then expects 1024 words (2kbytes) to replace it</desc>
			<type>_WRITE_CMD_</type>
			<base>t</base>
			<args>
				<arg>MS2_TABLE_INDEX</arg>
				<arg>PAUSE_50MS</arg>
				<arg>DATACHUNK</arg>
			</args>
		</cmd>
		<cmd>
			<name>ms1_get_clock</name>
			<desc>Triggers the ecu to echo back it's 8bit clock</desc>
			<type>_WRITE_CMD_</type>
			<base>C</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS1_CLOCK_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms2_get_clock</name>
			<desc>Triggers the ecu to echo back it's 16 bit clock</desc>
			<type>_WRITE_CMD_</type>
			<base>c</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS2_CLOCK_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms1_get_revision</name>
			<desc>Triggers the ecu to echo back it's textual revision</desc>
			<type>_WRITE_CMD_</type>
			<base>T</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_REVISION_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms2_get_revision</name>
			<desc>Triggers the ecu to echo back it's textual revision</desc>
			<type>_WRITE_CMD_</type>
			<base>R</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_REVISION_</helper_func_arg>
		</cmd>
		<cmd>
			<name>get_signature</name>
			<desc>Triggers the ecu to echo back it's api signature</desc>
			<type>_WRITE_CMD_</type>
			<base>S</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_SIGNATURE_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms1_veconst</name>
			<desc>Triggers the MS1 to return the VE/Constants for the previously set page</desc>
			<type>_WRITE_CMD_</type>
			<base>V</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS1_VECONST_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms2_veconst</name>
			<desc>Triggers the MS1 to return the VE/Constants for canID and page passed</desc>
			<type>_WRITE_CMD_</type>
			<base>r</base>
			<args>
				<arg>MS2_CAN_ID</arg>
				<arg>MS2_TABLE_INDEX</arg>
				<arg>MS2_OFFSET</arg>
				<arg>MS2_NUM_BYTES</arg>
			</args>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS2_VECONST_</helper_func_arg>
		</cmd>
		<cmd>
			<name>ms2_reinit</name>
			<desc>Triggers the ecu to recompute some soft init variables, required for some variables being modified</desc>
			<type>_WRITE_CMD_</type>
			<base>!x</base>
		</cmd>
		<cmd>
			<name>ms2_reboot</name>
			<desc>Triggers the ecu to reboot</desc>
			<type>_WRITE_CMD_</type>
			<base>!!x</base>
		</cmd>
		<cmd>
			<name>ms2_goto_bootloader</name>
			<desc>Triggers the ecu to reboot into the bootloader</desc>
			<type>_WRITE_CMD_</type>
			<base>!!!x</base>
			<helper_func>simple_read_cb</helper_func>
			<helper_func_arg>_MS2_BOOTLOADER_</helper_func_arg>
		</cmd>
		<cmd>
			<name>interrogation</name>
			<desc>Interrogates ECU to determine what it is</desc>
			<type>_FUNC_CALL_</type>
			<func_call_name>interrogate_ecu</func_call_name>
			<defer_post_functions>FALSE</defer_post_functions>
			<post_functions>
				<function>load_realtime_map</function>
				<function>initialize_dashboards</function>
				<function>load_status</function>
				<function>load_rt_text</function>
				<function>load_gui_tabs</function>
				<function>load_sliders</function>
				<function>start_statuscounts_cb</function>
				<function>populate_dlog_choices</function>
				<function>enable_interrogation_button_cb</function>
				<function>spawn_read_ve_const_cb</function>
				<function>reset_temps_cb</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms2_read_all</name>
			<desc>Reads ALL ecu vars for ALL modules </desc>
			<type>_FUNC_CALL_</type>
			<func_call_name>read_ve_const</func_call_name>
			<func_call_arg>_MS2_VECONST_</func_call_arg>
			<defer_post_functions>TRUE</defer_post_functions>
			<post_functions>
				<function>update_ve_const</function>
				<function>setup_menu_handlers</function>
				<function>enable_3d_buttons_cb</function>
				<function>set_store_black_cb</function>
				<function>enable_get_data_buttons_cb</function>
				<function>conditional_start_rtv_tickler_cb</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms1_read_all</name>
			<desc>Reads ALL ecu vars for ALL modules </desc>
			<type>_FUNC_CALL_</type>
			<func_call_name>read_ve_const</func_call_name>
			<func_call_arg>_MS1_VECONST_</func_call_arg>
			<defer_post_functions>TRUE</defer_post_functions>
			<post_functions>
				<function>update_ve_const</function>
				<function>setup_menu_handlers</function>
				<function>enable_3d_buttons_cb</function>
				<function>set_store_black_cb</function>
				<function>enable_get_data_buttons_cb</function>
				<function>enable_ttm_buttons_cb</function>
				<function>conditional_start_rtv_tickler_cb</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms1_e_read_trigmon</name>
			<desc>Reads trigmon page </desc>
			<type>_FUNC_CALL_</type>
			<func_call_name>read_ve_const</func_call_name>
			<func_call_arg>_MS1_E_TRIGMON_</func_call_arg>
			<defer_post_functions>TRUE</defer_post_functions>
			<post_functions>
				<function>crunch_trigtooth_data</function>
				<function>update_trigtooth_display</function>
			</post_functions>
		</cmd>
		<cmd>
			<name>ms1_e_read_toothmon</name>
			<desc>Reads toothmon page </desc>
			<type>_FUNC_CALL_</type>
			<func_call_name>read_ve_const</func_call_name>
			<func_call_arg>_MS1_E_TOOTHMON_</func_call_arg>
			<defer_post_functions>TRUE</defer_post_functions>
			<post_functions>
				<function_w_arg>crunch_trigtooth_data</function_w_arg>
				<function_w_arg>update_trigtooth_display</function_w_arg>
			</post_functions>
		</cmd>
	</commands>
</comms>
