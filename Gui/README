This README describes the contents of this dir and their file structure.

Last Edited, Sept 19th 16:04 PM

	Inside this dir "Gui", contains several files with a ".glade" and a 
".datamap" extension.  The .glade files are glade GUI description files 
written in XML and generated by the glade-2 gui designer.  They describe the
gui layout of a tab.  All widgets are named unique names and that is where
the datamap file comes from.  The datamap is laid out in .ini file format
using the common "section","key","value" layout as shown below.

[section]
key=value

What megatunix does, is that after it starts it checks to make sure an ECU
is present by issuing a comms test. (sends a "C" and checks for a response)
If that succeeds, Mtx then procedes to interrogate the ECU.  It does this
by reading a list of tests from a config file, then it will send the commands
to the ECU in turn and record the responses. Once all the responses are 
gathered, MegaTunix will load each interrogation profile in sequence, and 
attempt to match what it recorded with the profile,  once an exact match is 
found it will read a list of tab names to load from the interrogation profile 
and load those tabs followed by calling the "bind_data()" function for each
widget in the glade definition.  bind_data() looks inside the datamap file 
for a section named after the widget, and procedes to read the "keys" and 
"keytypes" fields from that section.  A check is run to make sure there are
the same number of keys and keytypes defined, and then each one of the keys
are loaded and bound to the widget using the g_object_set_data() call.  This
is done because all of the signal handlers throughout megatunix extract that
data to make apprpriate decisions about handling data.

NOTES regarding the datamap files:

1. The value names are CaSe SeNsItIvE, so be warned.  Ironically the
keys themselves are not, as the string compare functions are case insensitive.

2. Valid key_types are:
	_INT_		Integer value
	_ENUM_		String represnetation of an enumeration, translated via
			a call to "translate_string()"
	_STRING_	A literal string. (used for binding text to a widget
			that changes (like a temperature label))
	_BOOL_		A boolean, valid values are "TRUE" and "FALSE"

3. There is no limit to the number of keys that you can bind to a widget.

4. Most commonly used keys are:
	page		(integer) page in ecu that this control refers to
	offset		(integer) offset from the beginning of said page that
			this control refers to. 
	bit_val		(integer) the value of part of a bitfield (see below)
	bit_pos		(integer) the starting point in a bitfield for bit_val
	bitmask		(integer) the bitmask of bitval..
	temp_dep	(boolean) Temperature dependant widget (flag)
	c_label		(string)  Celcius label for temp dependant widgets
	f_label		(string)  Fahrenheit label for temp dependant widgets
	bind_to_list	(string)  A list of strings (keys) to lists that this
			widget is bound to. Used mainly to bind related 
			controls together for combined operations on them with
			some signal handler
	handler		(enum)	  A string representation of a signal handler
			choice, uses translate_string() to convert to an integer
	
	dl_conv_expr	(string)  A string representation of a mathematical
			expression. (something like x*60)  Used when a control
			is modified and the value needs conversion BEFORE
			sending to the ECU.
	ul_conv_expr	(string)  A string representation of a mathematical
			expression. (something like x*60)  Used when reading a
			variable FROM the ecu and convertign it to a value for
			the on-screen control. USUALLY a converse function to
			"dl_conv_expr" above.
	spconfig	(integer) Location of the sparkconfig variable.
			Special case that applies to only 1 widget... :(


