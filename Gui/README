This README describes the contents of this dir and their file structure.

    Inside this dir "Gui", contains several files with a .glade and a 
.datamap extension.  The .glade files are glade GUI description files 
written in XML and generated by the glade gui designer. They describe 
the Gui layout of a tab.  All widgets are named unique names and that 
is where the datamap file comes from.  The datamap is laid out in .ini 
file format using the common section,key,value layout as shown below.


[section]
key=value

When MegaTunix is loading a Gui tab it expect BOTH a .glade and .datamap file
Wehn a glade file is loaded, MegaTunix will traverse the XML tree of the glade
file in turn looking for each named widget in the .datamap file, and parsing 
that section as appropriate.  This is required because glade doesn't offer
the required fucntionality to bind specific data to each control within it's
UI, so this method was adopted to accomodate MegaTunix's needs.

Special Concerns:
  There are a few special sections common to all datamp files, specifically
the "global" and "defaults" sections.  The global section has some required
keys: tab_name which is hte name presented in the Main GUI, use a preceding
underscore if you want the next charactor underlined as a hotkey in the
main UI.  id_prefix, defines a textual string to prefix each widget name as 
stored within megatunix.  This is to prevent namespace clashes and allows the
re-use of the SAME glade file for multiple tabs (think multiple fuel tables).
The groups key lists the names of groups to be loaded FIRST. groups contain
default settings that can be applied to other controls, so it reduces the
repetition within the file, and eases maintenance. Multiple groups are allowed
and the names specified refer to additional sections which will be parsed
BEFORE any widget controls on that tab are parsed.  The "defaults" group
defines defaults that EVERY CONTROL will get, though they can be overridden
by other group's or control specific settings.  This is another method to 
reduce duplication.

Each section has a common key called "keys".  This is important.  Some people
will se this as duplication, however it serves a vitally important feature.
This lists the APPLICABLE keys to assign to this widget, MegaTunix will
search for these keys in this section and will error if they are not found, 
it is a way for the developer to EXPLICITLY specify which settings they want
applied to a widget, and prevents the need to test for every possible key
combination, which is wasteful and slow.

NOTES regarding the datamap files:

1. The value names are CaSe SeNsItIvE, so be warned.  Ironically the
keys themselves are not, as the string compare functions used are case 
insensitive.

2. There is no limit to the number of keys that you can bind to a widget.

3. Most commonly used keys: (This list is NOT complete and subject to change)
	group		(string) Points to a section to get additional 
			params from. See notes above regarding groups
	page		(integer) mtx_page in ecu that this control refers to
	offset		(integer) offset from the beginning of said page that
			this control refers to. 
	table_num	(string) Table number that this control applies to.
			The table number comes from the interrogation profile
			This is used for tables, interdependant controls that
			have special handlers.
	bitval		(integer) the value of part of a bitfield (see below)
	bitmask		(integer) the bitmask of bitval..
	temp_dep	(boolean) Temperature dependant widget (flag)
	label		(string)  normal label to use (See "swap_labels")
	alt_label	(string)  alternate label to use (See "swap_labels")
	c_label		(string)  Celsius label for temp dependant widgets
	f_label		(string)  Fahrenheit label for temp dependant widgets
	alt_c_label	(string)  Celsius label for temp dependant widget when
			another widget is at a specific state (see depend_on)
	alt_f_label	(string)  Celsius label for temp dependant widget when
			another widget is at a specific state (see depend_on)
	precision	(integer) number of decimal places to show
	reverse_keys	(boolean) Reverses the action of the +/- PgDn/PgUp 
			logic, for controls that use weird conversions.
	depend_on	(string) Name used to prepend the following vars (*)
	*_type		(enum) Types of vars to depend on
	*_page		(integer) Page in ve_vars
	*_offset	(integer) Offset in ve_Vars)
	*_bitmask	(integer) bitmask to mask value at page,offset
	*_bitval	(integer) value to match against for above 4 params
	swap_labels	(comma seperated string list). List of widget names OR
			GROUPNAMES (created with bind_to_list) to
			swap the labels based on the state of this widget. 
			Widget names and groups can be intermixed
			Currently applies to BITFIELD widgets ONLY. The target
			widget IF IT IS NOT TEMP DEPENDANT should have "label"
			and "alt_label" defined, otherwise it needs 4 keys
			defined: f_label, c_label, alt_f_label and alt_c_label.
			to handle all the possible states. The widget named
			must have the "depend_on" flag set and all the required
			keys for this to work as intended.. 
	bind_to_list	(string)  A list of strings (keys) of lists that this
			widget is bound to.  Used mainly to bind related 
			controls together for combined operations on them with
			some signal handler
	handler		(enum) A string representation of a signal handler
			choice, uses translate_string() to convert to an integer
	toggle_groups	(string) List of groups of widgets to enable/disable
			based on the state of this control.
	dl_type		(enum) Normal values are IMMEDIATE (means send the 
			value right away) and DEFERRED, meaning that the
			control is usually dependant on some calculation or
			interdependancy with other variables.  Not having
			a dl_type is OK, but is usually only used for controls
			that display something but don't directly map to an
			ECU location.
	fromecu_complex	(bool) A Flag signaling that the upload conversion is
			"complex" meaning that and extended parser is called to
			load the data. Required strings are ul_conv_expr,
			expr_symbols, and expr_types.  
	toecu_complex	(bool) A Flag signalling that the download conversion 
			is "complex" (same rules as ul_complex)
	toecu_conv_expr	(string)  A string representation of a mathematical
			expression. (something like x*60)  Used when a control
			is modified and the value needs conversion BEFORE
			sending to the ECU.
	fromecu_conv_expr	(string)  A string representation of a mathematical
			expression. (something like x*60)  Used when reading a
			variable FROM the ecu and converting it to a value for
			the on-screen control. USUALLY a converse function to
			"dl_conv_expr" above.
	expr_symbols	(string, comma delimited) Names of strings in the 
			{ud}l_conv_expr (ONLY used when {ud}l_complex is 
			defined as true) Lists the string names of all 
			variables in the expression, comma delimited.
	expr_types	(enums, comma delimited) Types of variables, goes hand
			in hand with expr_symbols above,  the number of 
			variables in this line and expr_symbols must be the
			same otherwise an eror is thrown. Valid types are
			_ECU_EMB_BIT_ (meaning a bitfield imbedded into the VE
			Variables, can be in any page), _ECU_VAR_ meaning just
			a VE variable, at any page offset.
	source		(string) string name of the source that this widget's
			state relies upon (bitfields ONLY).  The source names
			are defined in a RealTimeMap file that is firmware
			specific. (Specified in the interrogation profile)
			Used primarily for status indicators using data 
			from the realtime variables datasources...
	post_functions	(string) This is the textual list of pre-existing 
			functions within megatunix that will be ran after the
			tab is loaded and the datamap has been processed. The
			function will take no arguments and return nothing.
			This is used mainly for hybrid tabs that have their
			basic layout done in glade and are populated with 
			additional widgets in a more efficient manner by a 
			function. (see memory_gui.c for details )
	sub-notebook	(string) Special purpose key used so that the page
			change detector can extract the active table number 
			from the notebook tabs.  Used as a CPU saver to avoid
			updating windows that are not visible
Firmware Specific (MS)
	spconfig_offset	(integer) Offset of the corresponding spark trigger 
			config bitfield (linked to the control that uses this
			parameter)
	oddfire_bit_offset	(integer) Offset of the corresponding oddfire
			config bitfield (linked to the control that uses this
			parameter)
	ign_parm	(bool) Used to flag an ignition var for ONLY the 
			MSnS (NOT Extra series) and MSnEDIS, as they used a
			different command to write ignition variables to the
			ECU.

NOTE: regaring expr_symbols and expr_types:
	The expr_types in combination of expr_symbols determine what following
keys will be present in the section.  IF expr_symbols contains "cyls,reqfuel"
and expr_types contains "_ECU_EMB_BIT_,_ECU_VAR_" then the following fields will
be searched for. "cyls_page","cyls_offset","cyls_bitmask".
"reqfuel_page" and "reqfuel_offset". (Embedded bitfields need, the page,offset
and bitmask to be resolved completely), ECU_VAR's ony need the page 
and offset to be resolved.
completely.

HOW Bitfields are used:
	Controls that associate to a bitfield can either be a button, 
which is either a toggle (two choices) or radio (multiple choices) 
or a spinbutton in which a numerical value is stored into a bitfield 
(num_cylinders, etc..)  For buttons, in the datamap file we use bitval, 
and bitmask.

When clicking a button, what megatunix does is retrieve the byte at the 
page/offset set by that control, mask off the other bits in that byte with
the bitmask. (byte & bitmask)and set the new bits appropriately

When updating the button after reading the data from the ECU, we mask it and 
then shift it.  
	if((value%bitmask) >> bitshift) == bitval)
		Set button clicked
	else
		set button NOT clicked
i.e.
IF this value EQUALS bitval we set the buttons state to 
TRUE (clicked), otherwise we set it to FALSE.

For widgets we use "convert_after_upload" which checks for a simple or
complex conversion. (bitfield embedded values are considered a complex 
conversion due to handling the bit masking/shifting). See handle_complex_expr()
in the sourcecode.

